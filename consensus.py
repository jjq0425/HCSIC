'''
Description: This program simulates the changes in node reputation values (section 4.4)
'''

import random
import math

from matplotlib.cbook import flatten
import matplotlib.pyplot as plt

'''
Node Class: This program only simulates changes in reputation values, so it does not involve storing or sharding data
'''


class Node:
    def __init__(self, id, reputation,  started_malicious, ended_malicious, begin_epoch, existTime=0, constCandidate=0):
        self.id = id
        # Whether the node is blacklisted
        self.isBlackList = False
        # The reputation value of the node
        self.reputation = reputation

        # The time at which a node begins to be controlled (attacked)
        self.started_malicious = started_malicious  # -1. Identification does not start
        # The time at which a node ends to be controlled (attacked)
        self.ended_malicious = ended_malicious  # -1. Identification does not end

        # The time when nodes join the consensus group
        self.begin_epoch = begin_epoch

        '''
        The following three types of data affect the reputation value of nodes
        '''
        # Node existence time. Used to determine whether a node is an old node
        self.existTime = existTime
        # Whether the node is continuously selected as a candidate group. To ensure safety, re-election is generally not allowed.
        self.constCandidate = constCandidate
        # Was it a leader in the previous round
        self.isLeaderLastTime = False

        '''
        The following data is used to calculate the size of node block information.
        - Leaders nodes that are maliciously controlled will generate error blocks and perform signature verification on the error information; 
        - Normal nodes will generate correct blocks and only perform signature verification on the correct information
        '''
        # The number of blocks generated by the node (Right block)
        self.Good_block_count = 0
        # The number of blocks generated by the node (Error block)
        self.Bad_block_count = 0
        # The number of blocks vertified by the node (Right block)
        self.Good_block_vertify = 0
        # The number of blocks vertified by the node (Error block)
        self.Bad_block_vertify = 0

    def generBolck(self, isEvil):
        # If the node is a malicious node and a leader, an error block will be generated.
        #  (This function is only called when the node is the leader)
        if isEvil:
            self.Bad_block_count += 1
        else:
            self.Good_block_count += 1

    def vertiBlock(self, isEvil):
        # If the node is a malicious node and not a leader, incorrect signature verification will be performed.
        #  (This function is only called when the node is not the leader)
        if isEvil:
            self.Bad_block_vertify += 1
        else:
            self.Good_block_vertify += 1

    def getGenrBlockCount(self):
        # The total number of blocks generated by nodes
        return self.Good_block_count+self.Bad_block_count

    def getVerBlockCount(self):
        # The total number of blocks verified by nodes
        return self.Good_block_vertify+self.Bad_block_vertify

    def getGoodBlockCount(self):
        return self.Good_block_count

    def getBadBlockCount(self):

        return self.Bad_block_count

    def changeRep(self, change):
        self.reputation += change
        if (self.reputation <= 0):
            self.reputation = 0

    def getRep(self):
        return self.reputation

    def getId(self):
        return self.id

    def addBlackList(self):
        self.isBlackList = True
        print('The node has been blacklistedüö´\t', self.getId())

    def ADDexistTime(self):
        self.existTime += 1

    def changeLeaderTime(self, candidateList):
        findCandidate = False
        for candidate in candidateList:
            if candidate.getId() == self.id:
                if self.isLeaderLastTime:
                    # Is a candidate and was also a candidate in the previous round
                    self.constCandidate += 1
                    self.isLeaderLastTime = True
                    findCandidate = True
                    return
                else:
                    self.isLeaderLastTime = True
                    self.constCandidate = 0
                    findCandidate = True
                    return

            else:
                continue

        if not findCandidate:
            self.constCandidate = 0
            self.isLeaderLastTime = False


'''
This function is an election function that elects node leaders
'''


def election(nodes):

    nodes.sort(key=lambda x: x.getRep(), reverse=True)
    # Find the highest score
    best_score = nodes[0].getRep()
    # best_score = nodes[0].getRep()
    '''
    Consider two scenarios.
    The first is that there are many high scoring nodes, so you can directly select from them.
    The second reason is that there are very few high scoring nodes (typical cases such as having many new nodes), so choose the nodes with the higher score
    '''
    # Identify all nodes with scores equal to best_score and place them in the candidate list
    candidates1 = [node for node in nodes if node.getRep() == best_score]

    # Identify nodes with scores in the top 3
    candidates2 = nodes[:3]

    '''
    Randomly select a candidate from the list of candidates
    '''

    if len(candidates1) > 3:
        #
        for node in nodes:
            node.changeLeaderTime(candidates1)
        return random.choice(candidates1)
    else:
        # Ëã•Âè™ÊúâÂâç‰∏âÂÄôÈÄâ‰∫∫Ôºå
        for node in nodes:
            node.changeLeaderTime(candidates2)
        return random.choice(candidates2)


'''
Determine whether the current time of the node is under control
'''


def isdoEvil(Node, epoch):
    if Node.started_malicious == -1:
        return False
    elif Node.started_malicious <= epoch and Node.ended_malicious >= epoch or Node.started_malicious <= epoch and Node.ended_malicious == -1:
        return True
    else:
        return False


# Initialize 9 nodes
nodes = []
# Old node 1: After running for a short period of time, it will become a Byzantine node and then be released from control
nodes.append(Node(1, 100, 0, 10, 0, 100))
# Old node 2: It will serve as a Byzantine node for a long time during operation
nodes.append(Node(2, 100, 0, -1, 0, 100))
# Old nodes 3-6: Normal nodes
nodes.append(Node(3, 100, -1, 0, 0, 100))
nodes.append(Node(4, 100, -1, 0, 0, 100))
nodes.append(Node(5, 100, -1, 0, 0, 100))
nodes.append(Node(6, 100, -1, 0, 0, 100))

# New node 7: will be added from the beginning, with a reputation value of 0 and being a good node
nodes.append(Node(7, 0,  -1, 0, 0, 0))
# New node 8: will be added after a period of time (to verify dynamism) and is a good node
nodes.append(Node(8, 0,  -1, 0, 100, 0))
# New node 8: will be added after a period of time (to verify dynamism) and is a bad node
nodes.append(Node(9, 0,  100, -1, 100, 0))

EPOCH = 1000

# ----------------
LEADER_LAST = -1

a = 2
b = 8
c = 1
d = 0.8
k = 1.8

REP = [[] for _ in range(len(nodes))]

'''
Node reputation value calculation function
'''


def concludeRep(node, i, isEvil, D, isLeader=False):

    if isLeader:
        lambda_ = 1.1
    else:
        lambda_ = 1

    if isEvil:
        yita_ = -1.55
    else:
        yita_ = 1
    changeScore = lambda_*yita_*(1 / (1 + math.exp(a*node.constCandidate - b))) * \
        (1 / (1 + math.exp(c*node.existTime - D)) + k)
    return changeScore


for i in range(EPOCH):
    # print("epoch:", i)
    NowNodes = []
    # Identify all nodes with begin_epoch less than or equal to i (i.e. nodes that have already entered the consensus group)
    for node in nodes:
        if node.begin_epoch <= i:
            NowNodes.append(node)

    leader = election(NowNodes)

    # Find the number of nodes that appear in the growth stage (new nodes)
    GrowthNode = 0
    for node in NowNodes:
        if node.getRep() < 10:
            GrowthNode += 1

    # Calculate the average reputation value of nodes
    if len(NowNodes) > 0:
        avg_rep = sum(node.getRep()
                      for node in NowNodes) / (len(NowNodes))
    else:
        avg_rep = 0
    # Set D: It could dynamically adjust the number of incentive rounds for the new node
    D = avg_rep*d

    '''
    Perform different behaviors based on whether the node is committing evil or not
    '''
    isEvil = isdoEvil(leader, i)
    if isEvil:
        # print(i, "leader:", leader.getId(), "is malicious")
        leader.changeRep(concludeRep(leader, i, isEvil, D, True))
        leader.generBolck(isEvil)
    else:
        # print(i, "leader:", leader.getId(), "is not malicious")
        leader.changeRep(concludeRep(leader, i, isEvil, D, True))
        leader.generBolck(isEvil)

    for node in NowNodes:
        if node.getId() != leader.getId():
            if isdoEvil(node, i):
                node.changeRep(concludeRep(node, i, isdoEvil(node, i), D))
                node.vertiBlock(isEvil)
            else:
                node.changeRep(concludeRep(node, i, isdoEvil(node, i), D))
                node.vertiBlock(isEvil)

    # Change the existence time of nodes
    for node in NowNodes:
        node.ADDexistTime()
    # LEADER_LAST = leader.getId()

    # TmpScore = []
    # for node in nodes:
    #     TmpScore.append(node.getRep())
    # Deposit the reputation value of the node
    for node in nodes:
        REP[node.id-1].append(node.getRep())

'''
The following is a graphical function that displays the changes in reputation values for typical four nodes
'''
show_idx = [0, 2, 6, 7]
plt.figure(dpi=200)
plt.style.use('seaborn-paper')
for node_idx, node_val in enumerate(REP):
    END = 300
    x = range(0, END, 30)
    y = [node_val[i] for i in x]
    if node_idx == 0:
        plt.plot(x, y, 'o-',
                 label='Node {}'.format(node_idx+1), zorder=100, linewidth=2, markersize=8, color='#ff6348')
        print('0', y)
    if node_idx == 2:
        plt.plot(x, y, 's-', label='Node {}'.format(node_idx+1),
                 linewidth=2, markersize=8, color='#20bf6b')
        print('2', y)
    if node_idx == 6:
        plt.plot(x, y, '^-', label='Node {}'.format(node_idx+1),
                 linewidth=2, markersize=8, color='#34ace0')
        print('6', y)
    if node_idx == 7:
        x = range(100, END, 30)
        y = [node_val[i] for i in x]
        plt.plot(x, y, 'd-', label='Node {}'.format(node_idx+1),
                 linewidth=2, markersize=8, color='#4b7bec')
        print('7', y)

plt.xlabel('ROUND')
plt.ylabel('REP')
plt.legend()

plt.title('')
plt.xlabel('Number of rounds')
plt.ylabel('The reputation value')
# ÁæéÂåñÂõæÂΩ¢
plt.grid(True)
plt.tight_layout()
plt.show()
